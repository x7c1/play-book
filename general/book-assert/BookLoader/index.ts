import { ChapterHeading, ReadmeHeading, Summary } from "../summary";
import { DirectoryPath } from "../../file-paths/DirectoryPath";
import { FilePath } from "../../file-paths/FilePath";
import { promisify } from "util";
import { readFile } from "fs";
import * as md from "markdown-it";
import * as cheerio from "cheerio";
import { BookChapters, ChapterContent } from "../BookChapter";
import { ChapterLoader } from "../BookIndexer";

export class BookLoader {
  constructor(
    private root: string,
    private loadChapter: ChapterLoader,
    private readmePath: FilePath,
    private chapterPaths: DirectoryPath[],
  ) {}

  async loadSummary(): Promise<Summary> {
    return {
      readme: await this.loadReadmeHeading(),
      chapters: await this.loadChapterHeadings(),
    };
  }

  async loadBookChapters(): Promise<BookChapters> {
    const promises = this.chapterPaths.map(loadChapterContent);
    return Promise.all(promises).then(contents => ({ contents }));
  }

  private async loadReadmeHeading(): Promise<ReadmeHeading> {
    return loadReadme(this.readmePath);
  }

  private async loadChapterHeadings(): Promise<ChapterHeading[]> {
    console.log("loadChapters", this.root, this.chapterPaths);
    return Promise.all(this.chapterPaths.map(this.loadChapterHeading));
  }

  private async loadNextPages(
    chapterPath: DirectoryPath,
    chapterNumber: number,
  ): Promise<PageHeading[]> {
    const chapter = await this.loadChapter(chapterNumber);
    if (!chapter) {
      return Promise.resolve([]);
    }
    const promises = chapter.nextPages.map(async name => {
      const filePath = await chapterPath.withParent.confirmFile(name);
      const fromHtml = (html: string) => {
        const $ = cheerio.load(html);
        return {
          title: $("h1").text(),
          path: filePath.toRelative,
        };
      };
      return promisify(readFile)(filePath.toAbsolute, "utf-8")
        .then(fromMarkdown)
        .then(fromHtml);
    });
    return Promise.all(promises);
  }

  private loadChapterHeading = async (
    chapterPath: DirectoryPath,
    chapterIndex: number,
  ) => {
    const index = await chapterPath.withParent.confirmFile("index.md");
    const nextPages = await this.loadNextPages(chapterPath, chapterIndex + 1);
    const fromHtml = (html: string) => {
      const $ = cheerio.load(html);
      const h1 = $("h1").text();
      return {
        title: `${chapterIndex + 1}. ${h1}`,
        path: index.toRelative,
        nextPages,
      };
    };
    return promisify(readFile)(index.toAbsolute, "utf-8")
      .then(fromMarkdown)
      .then(fromHtml);
  };
}

const fromMarkdown = (markdown: string) => md().render(markdown);

function loadReadme(path: FilePath): Promise<ReadmeHeading> {
  const fromHtml = (html: string) => {
    const $ = cheerio.load(html);
    return {
      title: $("h1").text(),
      path: path.toRelative,
    };
  };
  return promisify(readFile)(path.toAbsolute, "utf-8")
    .then(fromMarkdown)
    .then(fromHtml);
}

function toAnchor(text: string): string {
  return text
    .replace(/[.:]/g, "")
    .replace(/[ ]/g, "-")
    .toLowerCase();
}

const warning = `
{% if false %}

* This file is automatically generated by book-assert library.
* Do not modify this file -- YOUR CHANGES WILL BE ERASED!

{% endif %}
`;
